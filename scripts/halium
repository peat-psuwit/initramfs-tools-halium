# Local filesystem mounting			-*- shell-script -*-

_log_msg() {
	if [ "$quiet" = "y" ]; then return; fi
	printf "$@" > /dev/kmsg || true
}

pre_mountroot() {
	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
	run_scripts /scripts/local-top
	[ "$quiet" != "y" ] && log_end_msg
}

tell_kmsg() {
	# Echos a string into /dev/kmsg, ignoring errors.
	echo "initrd: $1" >/dev/kmsg || true
}

halium_panic() {
	# Puts panic reason into kmsg and then starts the panic handlers
	REASON="$1"
	tell_kmsg "PANIC for reason: $REASON"
	panic $REASON
}

sync_dirs() {
	base=$1
	source=$2
	target=$3

	OLD_PWD=$PWD
	cd $base

	for file in $source/*; do
		# Skip empty directories
		[ ! -e "$base/$file" ] && continue

		# If the target already exists as a file or link, there's nothing we can do
		[ -e "$target/$file" -o -L "$target/$file" ] && [ ! -d "$target/$file" ] && continue

		# If the target doesn't exist, just copy it over
		if [ ! -e "$target/$file" -a ! -L "$target/$file" ]; then
			cp -Ra "$base/$file" "$target/$file"
			continue
		fi

		# That leaves us with directories and a recursive call
		[ -d $file ] && sync_dirs $base $file $target
	done

	cd $OLD_PWD
}

resize_userdata_if_needed() {

	# See if the filesystem on the userdata partition needs resizing (usually on first boot).
	# If the difference between the partition size and the filesystem size is above a small
	# threshold, assume it needs resizing to fill the partition.

	path=$1

	# Partition size in 1k blocks
	case $path in
	/dev/mmcblk*)
		pblocks=$(grep ${path#/dev/*} /proc/partitions | awk {'print $3'})
		;;
	/dev/disk*)
		pblocks=$(grep $(basename $(readlink $path)) /proc/partitions | awk {'print $3'})
		;;
	esac
	# Filesystem size in 4k blocks
	fsblocks=$(dumpe2fs -h $path | grep "Block count" | awk {'print $3'})
	# Difference between the reported sizes in 1k blocks
	dblocks=$((pblocks - 4 * fsblocks))
	if [ $dblocks -gt 10000 ]; then
		resize2fs -f $path
		tell_kmsg "resized userdata filesystem to fill $path"
	fi
}

identify_file_layout() {
	# Determine if we have a Halium rootfs.img & system.img

	# $file_layout = "halium" means there is a separate rootfs.img and system.img on userdata
	#
	# = "partition" means the rootfs is located on the device's system partition
	# and will contain /var/lib/lxc/android/system.img
	#
	# = "subdir" means the rootfs is located in a folder on the device's userdata partition
	# and will contain /var/lib/lxc/android/system.img

	if [ -e /tmpmnt/rootfs.img ]; then
		imagefile=/tmpmnt/rootfs.img
		file_layout="halium"
	elif [ -e /tmpmnt/ubuntu.img ]; then
		imagefile=/tmpmnt/ubuntu.img
		file_layout="legacy"
	elif [ -d /tmpmnt/halium-rootfs ]; then
		imagefile=/tmpmnt/halium-rootfs
		file_layout="subdir"
	else
		file_layout="partition"
	fi

}

process_bind_mounts() {
	# Goes over /etc/system-image/writable-paths to create the correct fstab for
	# the bind-mounts. Writes them into ${rootmnt}/run/image.fstab which is
	# bind-mounted to /etc/fstab

	if [ ! -e ${rootmnt}/etc/system-image/writable-paths ]; then
		tell_kmsg "This rootfs does not have any writable-paths defined"
		return 0
	fi

	# Mount a tmpfs in /run of rootfs to put the future image.fstab
	mount -o rw,nosuid,noexec,relatime,mode=755 -t tmpfs tmpfs ${rootmnt}/run
	# Prepare the fstab
	FSTAB=${rootmnt}/etc/fstab
	touch ${rootmnt}/run/image.fstab
	mount -o bind ${rootmnt}/run/image.fstab $FSTAB ||halium_panic "Could not bind-mount fstab"
	echo "/dev/root / rootfs defaults,ro 0 0" >>$FSTAB

	tell_kmsg "Adding bind-mounts to $FSTAB"
	# Process the list of bind-mounts
	# (but don't mount them, mountall will do it)
	cat ${rootmnt}/etc/system-image/writable-paths | while read line; do
		set -- $line
		# Skip invalid/commented entries
		([ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ] || [ -z "$5" ]) && continue
		[ "$1" = "#" ] && continue

		# Skip invalid mount points
		dstpath="${rootmnt}/$1"
		[ ! -e "$dstpath" ] && continue

		if [ "$3" = "temporary" ]; then
			# Temporary entries are simple, just mount a tmpfs
			echo "tmpfs $1 tmpfs $5 0 0" >>$FSTAB
		elif [ "$3" = "persistent" ] || [ "$3" = "synced" ]; then
			# Figure out the source path
			if [ "$2" = "auto" ]; then
				srcpath="${rootmnt}/userdata/system-data/$1"
				path="/userdata/system-data/$1"
			else
				srcpath="${rootmnt}/userdata/$2"
				path="/userdata/$2"
			fi

			if [ ! -e "$srcpath" ]; then
				# Process new persistent or synced paths
				dstown=$(stat -c "%u:%g" $dstpath)
				dstmode=$(stat -c "%a" $dstpath)
				mkdir -p ${srcpath%/*}
				if [ ! -d "$dstpath" ]; then
					# Deal with redirected files
					if [ "$4" = "transition" ]; then
						cp -a $dstpath $srcpath
					else
						touch $srcpath
						chown $dstown $srcpath
						chmod $dstmode $srcpath
					fi
				else
					# Deal with redirected directories
					if [ "$4" = "transition" ] || [ "$3" = "synced" ]; then
						cp -aR $dstpath $srcpath
					else
						mkdir $srcpath
						chown $dstown $srcpath
						chmod $dstmode $srcpath
					fi
				fi
			elif [ "$3" = "synced" ]; then
				# Process existing synced paths
				sync_dirs $dstpath . $srcpath
			fi

			if [ "$5" = "none" ]; then
				mount_opts="bind"
			else
				mount_opts="bind,$5"
			fi

			# mount all /etc dirs right now, not later when fstab is
			# processed, as it will cause races (e.g. /etc/machine-id).
			case "$1" in
				/etc/*)
					mount -o "$mount_opts" "$srcpath" "$dstpath"
					;;
				*)
					echo "$path $1 none $mount_opts 0 0" >>$FSTAB
					;;
			esac
		else
			continue
		fi
	done
}

mountroot() {
	# list of possible userdata partition names
	partlist="userdata UDA DATAFS USERDATA"

	pre_mountroot

	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-premount"
	run_scripts /scripts/local-premount
	[ "$quiet" != "y" ] && log_end_msg

	# Put all of this script's output into /dev/kmsg
	exec &>/dev/kmsg

	# Mount root
	#
	# Create a temporary mountpoint for the bindmount
	mkdir -p /tmpmnt

	# Make sure the device has been created by udev before we try to mount
	udevadm settle

	# find the right partition
	for partname in $partlist; do
		part=$(find /dev -name $partname | tail -1)
		[ -z "$part" ] && continue
		path=$(readlink -f $part)
		[ -n "$path" ] && break
	done

	# override with a possible cmdline parameter
	if grep -q datapart= /proc/cmdline; then
		for x in $(cat /proc/cmdline); do
			case ${x} in
			datapart=*)
				path=${x#*=}
				;;
			esac
		done
	fi

	if [ -z "$path" ]; then
		halium_panic "Couldn't find data partition."
	fi

	tell_kmsg "checking filesystem integrity for the userdata partition"
	# Mounting and umounting first, let the kernel handle the journal and
	# orphaned inodes (faster than e2fsck). Then, just run e2fsck forcing -y.
	# Also check the amount of time used by to check the filesystem.
	fsck_start=$(date +%s)
	mount -o errors=remount-ro $path /tmpmnt
	umount /tmpmnt
	e2fsck -y $path >/run/e2fsck.out 2>&1
	fsck_end=$(date +%s)
	tell_kmsg "checking filesystem for userdata took (including e2fsck) $((fsck_end - fsck_start)) seconds"

	resize_userdata_if_needed ${path}

	tell_kmsg "mounting $path"

	# Mount the data partition to a temporary mount point
	# FIXME: data=journal used on ext4 as a workaround for bug 1387214
	[ `blkid $path -o value -s TYPE` = "ext4" ] && OPTIONS="data=journal,"
	mount -o discard,$OPTIONS $path /tmpmnt

	# Set $_syspart if it is specified as systempart= on the command line
	if grep -q systempart= /proc/cmdline; then
		for x in $(cat /proc/cmdline); do
			case ${x} in
			systempart=*)
				_syspart=${x#*=}
				;;
			esac
		done
	fi

	identify_file_layout

	# If both $imagefile and $_syspart are set, something is wrong. The strange
	# output from this could be a clue in that situation.
	tell_kmsg "Halium rootfs is $imagefile $_syspart"

	# Prepare the root filesystem
	# NOTE: We mount it read-write in all cases, then remount read-only.
	#       This is to workaround a behaviour change in busybox which now
	#       uses read-only loops if the fs is initially mounted read-only.
	#       An alternative implementation would be to add losetup support
	#       to busybox and do the mount in two steps (rw loop, ro fs).

	mkdir -p /halium-system

	tell_kmsg "mounting system rootfs at /halium-system"
	if [ -n "$_syspart" ]; then
		mount -o rw $_syspart /halium-system
	elif [ -f "$imagefile" ]; then
		# Rootfs is an image file
		mount -o loop,rw $imagefile /halium-system
	elif [ -d "$imagefile" ]; then
		# Rootfs is a directory
		mount -o bind /tmpmnt/halium-rootfs /halium-system
	fi

	# If either (android) /data/.writable_image or (on rootfs)
	# /.writable_image exist, mount the rootfs as rw
	if [ -e /tmpmnt/.writable_image ] || [ -e /halium-system/.writable_image ]; then
		tell_kmsg "mounting $_syspart $imagefile (image developer mode)"
		mountroot_status="$?"
	else
		# Neither of those exist, remount read-only
		tell_kmsg "mounting $_syspart $imagefile (user mode)"
		mount -o remount,ro /halium-system
		mountroot_status="$?"
	fi

	if [ -e $imagefile ] || [ -n "$_syspart" ]; then
		tell_kmsg "Found rootfs"

		mount --move /halium-system ${rootmnt}
		mkdir -p ${rootmnt}/android

		# Mounting userdata outside of /android, to avoid having LXC container access it
		mkdir -p ${rootmnt}/userdata
		mount --move /tmpmnt ${rootmnt}/userdata

		process_bind_mounts

		# Bind-mount /var/lib/ureadahead if available on persistent storage
		# this is required because ureadahead runs before mountall
		if [ -e ${rootmnt}/userdata/system-data/var/lib/ureadahead ] &&
			[ -e ${rootmnt}/var/lib/ureadahead ]; then
			mount --bind ${rootmnt}/userdata/system-data/var/lib/ureadahead ${rootmnt}/var/lib/ureadahead
		fi

		# Apply customized content
		for user in ${rootmnt}/userdata/user-data/*; do
			if [ -d ${rootmnt}/custom/home ] && [ ! -e "$user/.customized" ]; then
				tell_kmsg "copying custom content tp "
				cp -Rap ${rootmnt}/custom/home/* "$user/"
				cp -Rap ${rootmnt}/custom/home/.[a-zA-Z0-9]* "$user/"
				touch "$user/.customized"
				dstown=$(stat -c "%u:%g" "$user")
				chown -R $dstown "$user/"
			fi
		done

	else
		# Possibly a re-partitioned device
		halium_panic "Couldn't find a system partition."
	fi

	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-bottom"
	run_scripts /scripts/local-bottom
	[ "$quiet" != "y" ] && log_end_msg
}
